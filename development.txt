[UNIVERSAL BUSINESS LANGUAGE]
This application is python implementation of the UBL 2.0 specification for
business documents and processes. The core ideas of the this project are
geared towards building faster business application for web, mobile etc.

[DESIGN AND IMPLEMENTATION CONSIDERATIONS]
The abstract base types of the UBL will be implemented using the abc.ABC
class or derivative of the Abstract Base Classes. The concept of business
service object will be used while still keeping in line with recommendation
from the UBL tech committee. The business service object will enable a
mathematical/logical modelling of business operations using formal symbols as
 described by set, logic, and algebraic expressions.
This approach is aimed at making testing and class implementation to be a lot
 more structured and clear.

Python implementation constructs such as decorators, asyncio.Task, asyncio
.Futures, asyncio.Coroutines, Generators and others will be used to implement
 mathematical models or building blocks.

Example:
Sequential operation will be implemented using Generators (yield statement),
Coroutines or asyncio.Task Set operations will be implemented using builtin
set or collection classes. Operations such as equals, greater than, etc can
be achieved by overriding special methods __eq__, __gt__, __and__ etc.

The python implementation will use data structures such as OrderedDict,
NamedTuples (or derivative classes) as templates or structures for core xml
schemas.
There may not be a one to one mapping of these structures to the xml
definition. Also, classes having only data attributes may not fit the concept
of OOP thus using existing data structures to ease access, sorting and other
behaviours will be preferred. Large xml schemas will be mapped to generators
enabling a caller to iterate through the entire structure easily while object
is loaded to memory.
Functions for optimising searches or retrieving particular information from
attributes (implemented tags) may be added. Such functions could be defined
as special methods in the core components (BIE, ABIE classes) or as
properties in their respective python implementations.

[CONFIGURATION OVER CONVENTION]
The ubl mappings will have a large list of attributes matching to data.
These fields can be configured dynamically or statically from a configuration
or setting file.
This will enable various businesses simply specify their parameters,
attributes to ignore or hide, compulsory fields etc. and have the application
create corresponding datatypes using the type('BSOType', (), {}) to make
instances or classes.

[STANDARD BUSINESS SERVICES]
"Every business services consist of activities performed at a cost and
requiring feedback (proof of transaction)"
The above quote defines the Business Service Object paradigm.
This method of building business application requires that all services
provided by the business be mapped to corresponding set of business
activities and feedback. The business activities will be defined as
actionable tasks that can be performed by an entity such as a human actor
(accountant, administrator etc.), a system, or subsystem.
The feedback may be in various format or through different media example
paper invoices, electronic mails, credit alerts etc.
This approach is mathematically modelled as Equation 1:
 fx(bs) = [h(px) => g(tx)] and [i(bx) => h(px)]
 Where fx(bs): defined Business Service being provided
  h(px): defined function for managing payment or the cost of the business
  activity
  g(tx): defined function for managing the transaction generated with each
  actionable task
  i(bx): defined function for managing the business feedback such as function
   to generate an electronic invoice
  =>: logical symbol showing material dependence or implication.
  A => B is true if and only if B can be true and A can be false but not vice
   versa
  and: logical AND operation

The business activity consists of transactions. A transaction is an exchange
of value inherent in an item, commodity, or service. Thus, the business
activity is identified by transaction(s) which exist when value is exchanged.
Inculcating the activity, transaction and item into the business service.
We obtain Equation 2:
 g(tx) = c(tx) and j(vx)
 Where g(tx): defined function for managing the transaction generated with
 each actionable task
 c(tx): depicts the cost of the transaction. This is different from the cost of
 the valuable asset or item being exchanged. The cost of the transaction may
 be computed or fixed value
 j(vx): defined function for managing the item or valuable of exchange

 Substituting for g(tx) in Equation 1:
 fx(bs) = [h(px) => [ct and j(vx)]] and [i(bx) => h(px)]

The Universal Business Language (UBL) defines a set of business information
elements. These elements can be used to build information blocks of various
business documents which are offshoots of different processes.
They also provide a generic schema for defining bespoke business document.
Using OASIS UBL standard and implementation guide, electronic business documents
can be produced to hold data of businesses.
This package (Business Service Object) implements UBL specification as a
Python module targeting the django web framework.

[UNIVERSAL BUSINESS LANGUAGE MAPPING TO BUSINESS SERVICE OBJECT]
The Business Service objects will rely on the Universal
Business Language in generating documents. The UBL implementation
classes (BusinessDocument, DocumentFactory) holds data or attributes fields for
used to create various business document/information. A system user can define
his/her documents (e.g invoice, receipt) which are built off the UBL
implementation and dynamically saved to database.

When a business service is performed, the necessary bso document is generated
 from the default or user's defined documents as feedback for a business
 service. This allows for extensible and easily configurable business documents.

Another benefit achieved from adopting UBL is the having a defined list of
business activities and agreed business processes adopted by a growing client
 base.
From UBL, defined documents are produced by identified business processes.
These processes may be executed in different ways by different businesses (i.e
 affected by the business culture) but essentially retain common meaning.
Example, payments may be done in several steps by different businesses but
overall a payment simply implies exchange of value settled with a legal
instrument like cash or gold.

Using the data nomenclature and UML specification of UBL, business
systems can be defined for various use cases. These systems may be overridden
 in target business scenarios saving development time and resources.

A typical business system will comprise these components:
1. Activity or Actionable Task (User action, e.g a purchase)
2. Private Business Culture (internal/external Processes and services)
3. Feedback (instances of UBL document e.g invoice)

The user action is consumed by the business culture and procedure.
The business in turn produces a proof of transaction which is given as feedback.
Now UBL defines the feedback as documents (information elements) and lists
the typical user's activities leading to these documents. What cannot be
defined ahead of time is the business culture as this will be an infinite set
of processes. However, any given business process can be represented as a
"black box" with fixed input (user action) and clearly defined output
(feedback). Using this approach, the business system can be represented by
classes or objects initiated by user's action and returning feedback.
This base structure can be extended as required to fit target businesses.

[DEFINING BUSINESS SERVICE OBJECTS]
The various business service objects can broadly be categorised into:
Transactions
Item or Valuables
Business Activity
Business Document or Feedback

[APPLICATION BEHAVIOURAL DESIGN]
The application is designed to simplify business processes by adopting the
defined workflow in the UBL 2.1 specifications. Furthermore, a generic
business service pattern will be used to enforce the adopted workflow.
The business service pattern can be defined thus:
1. All business processes' yield feedback that will be managed using
appropriate Notice classes from a messaging package
2. All defined ubl datatypes or components are defined as BusinessDocuments
its derivative classes. These documents will be composed in BusinessService
interface that will be used in implementing a business process. The
BusinessDocument will not to be instantiated but generated through
their respective Builder classes or DocumentFactory.
3. The management of a given business service will be done through defined
BSOManagement classes e.g TenderManagement. These
management classes will provide the interfaces by which a given BSO will be
accessed, modified, or operated.
4. The Management classes wraps their respective BSO or is associated with a
BSOBuilder by which it can manage system and user's requests.

[EBXML SUPPORT]
Future implementation of BusinessObject will support the Electronic Business
XML schema.
This will enable having a rich set of business documents that are operable
across various systems.

[BUSINESS DOCUMENT DESIGNER]
The need to extend or generate various types of business documents will be
supported by the templating mechanism. This approach will allow for a
Document Factory to generate various types of custom documents by calling
design_document(definitions) where the parameter definitions will provide a
mapping of identifiers/fields and their corresponding BIE or ABIE elements.
This feature will likely be added in version 2.

[IMMUTABLE BUSINESS PROOFS, TASKS, AND STATE]
Business document will be designed to be immutable. This will be achieved by
defining the __slots__() variable in each document. Also the __setattr__()
method call for all business document of the descriptor will not support
modifying the attributes of a document.

Every document is not instantiated or created directly. Calls to __new__ or
__init__ simply not create a default instance with attributes that cannot be
modified.

To save state, all documents are saved to a central DocumentQueue. Similarly,
tasks are saved to a central TaskQueue. The overall state of a system can be
considered as the collection of documents produced and the meta data of the
tasks which produced these documents. Any process can be reconstructed
having these pieces of information.

[ERROR/DEBUG MESSAGE]
Define a central messaging system which identifies messages as enums with
fixed values and keys. The keys can serve as a lookup to trace source of
error during debugging. This system will enable centralized location of all
messages

[DOCUMENT GENERATOR] - IMPLEMENTED
The BusinessDocumentFactory.produce_document(document) can be called in a
for loop or similar iterator to generate multiple documents. By keeping a
reference of document generated as instance, future request for that document
 can simply be copied instead of created.

[PARSING XML]
The application can be used to parse xml document into python dictionary or
equivalent data structure. Existing parsers convert xml to dict enabling
developers access information in a dictionary-like manner. BSO was designed
to enable application developer access fields as attributes or items of a
collection abstracting the xml parent-child nested structure. Future edition
can incorporate a more elaborate scheme as described below:
Example
order = Order(definitions)
order.get('field', None)
order.set('field', value)
order.field
order.field.__meta__ # returns tha xml metadata for this field
order.field.__parent__ # return the parent node of this field or None if root
order.field.__children__ # return children nodes of this field as a list

[CACHING DOCUMENT] - IMPLEMENTED
Using metaclasses or a cache manager that relies on the weakref value
dictionary, business documents can be created and cached by the prototyping
class or factory. This will enable objects to be removed only during garbage
collection and created only if non existent in memory/cache.

[EXTENDING DOCUMENT FIELDS] - IMPLEMENTED
The UBL document library specifies the fields of each electronic document.
The implementation of this specification may not meet requirement of various
businesses. The need to extend a document field thus arises. One approach
will entail simply patching extra fields to the base document definition.
Another approach, the one adopted herein, uses an __ext class variable as an
expansion slot to which extra fields and their corresponding values or
definitions can be appended to a document. Having this attribute will enable
the various classes to expand functionality to meet specific business needs

[ASSOCIATING DOCUMENT COMPONENT]
The various document may have relationship fields that references other
components or documents. These fields are generally depicted by the asbie
type which is lazily evaluated. In essence, the actual component that is
reference may not be known ahead or can be set after creating document. This
lazy evaluation allows for flexible and easier control of the document life
cycle also enabling document designers swap components dynamically by
changing the target of the association. asbie types simply serve as 'blank'
association objects or as dynamic reference pointers.

[DOCUMENT WRITER]
This feature will convert the various document templates into designated
electronic formats such as DOCX, PDF etc.